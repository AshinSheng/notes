缓存是一种保存资源副本并在下次请求时直接使用该副本的技术。当 web 缓存发现请求的资源已经被存储，它会拦截请求，返回该资源的拷贝，而不会去源服务器重新下载。这样带来的好处有：缓解服务器端压力，提升性能(获取资源的耗时更短了)。


# 缓存控制

## Cache-control

 Cache-Control 头是HTTP/1.1定义的，通过它提供的不同的值来定义缓存策略，请求头和响应头都支持这个属性。
 
  - __Cache-Control: no-store__  
  禁止进行缓存。每次由客户端发起的请求都会下载完整的响应内容。

  - __Cache-Control: no-cache__  
  强制确认缓存。每次有请求发出时，缓存会将此请求发到服务器（译者注：该请求应该会带有与本地缓存相关的验证字段），服务器端会验证请求中所描述的缓存是否过期，若未过期（注：实际就是返回304），则缓存才使用本地缓存副本。
  
  - __Cache-Control: private__  
  表示该响应是专用于某单个用户的，中间人不能缓存此响应，该响应只能应用于浏览器私有缓存中。

  - __Cache-Control: public__  
  "public" 指令表示该响应可以被任何中间人（比如中间代理、CDN等）缓存。若指定了"public"，则一些通常不被中间人缓存的页面（因为默认是private）（比如 带有HTTP验证信息（帐号密码）的页面 或 某些特定状态码的页面），将会被其缓存。

  - __Cache-Control: max-age=\<seconds>__  
  表示资源能够被缓存（保持新鲜）的最大时间（距离请求发起的时间的秒数）。

  - __Cache-Control: must-revalidate__  
  缓存在考虑使用一个陈旧的资源时，必须先验证它的状态，已过期的缓存将不被使用。





## Pragma: no-cache
与 Cache-Control: no-cache 效果一致。
是一个在 HTTP/1.0 中规定的通用首部。由于 Pragma 在 HTTP 响应中的行为没有确切规范，所以不能可靠替代 HTTP/1.1 中通用首部 Cache-Control，尽管在请求中，假如 Cache-Control 不存在的话，它的行为与 Cache-Control: no-cache 一致。建议只在需要兼容 HTTP/1.0 客户端的场合下应用 Pragma 首部。

## Expires: <http-date>
Expires 响应头包含日期/时间， 即在此时候之后，响应过期。无效的日期，比如 0, 代表着过去的日期，即该资源已经过期。如果在Cache-Control响应头设置了 "max-age" 或者 "s-max-age" 指令，那么 Expires 头会被忽略。
> Expires: Wed, 21 Oct 2015 07:28:00 GMT


# 新鲜度
- 由于缓存只有有限的空间用于存储资源副本，所以缓存会定期地将一些副本删除，这个过程叫做缓存驱逐。
- 当服务器上面的资源进行了更新，那么缓存中的对应资源也应该被更新，由于HTTP是C/S模式的协议，服务器更新一个资源时，不可能直接通知客户端更新缓存，所以双方必须为该资源约定一个过期时间，在该过期时间之前，该资源（缓存副本）就是新鲜的，当过了过期时间后，该资源（缓存副本）则变为陈旧的。