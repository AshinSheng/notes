
# HTML解析

## 语法
- 因为HTML的语法不是与上下文无关的，所以常规解析器（它们可以用于解析CSS和Javascript）也不适用于解析HTML。导致HTML语法的特殊性主要原因在于：
> - 语言的宽容本质。
> - 浏览器历来对一些常见的无效 HTML 用法采取包容态度。
> - 解析过程需要不断地反复。源内容在解析过程中通常不会改变，但是在 HTML 中，脚本标记如果包含 document.write，就会添加额外的标记，这样解析过程实际上就更改了输入内容。  
- HTML 的词汇和语法在 W3C 组织创建的[规范]()中进行了定义，当前的版本是HTML5。  
- HTML 的定义采用DTD（Document Type Definition）格式，此格式可用于定义[SGML]族的语言。它包含了所有允许使用的元素及其属性、层次结构的定义。它无法构成与上下文无关的语法。

## 解析算法
HTML的解析算法由两个阶段组成：__标记化__ 和 __树构建__。如下图：  

<img src="./htmlParse.svg" width="300"/>

标记化是词法分析过程，将输入内容解析成多个标记。HTML 标记包括起始标记、结束标记、属性名称和属性值。标记生成器识别标记，传递给树构造器，然后接受下一个字符以识别下一个标记；如此反复直到输入的结束。

### 标记化算法
该算法使用状态机来表示。每一个状态接收来自输入信息流的一个或多个字符，并根据这些字符更新下一个状态。当前的标记化状态和树结构状态会影响进入下一状态的决定。这意味着，即使接收的字符相同，对于下一个正确的状态也会产生不同的结果，具体取决于当前的状态。  
大部分语言的词法部分都是通过状态机实现的。以下是部分词（token）的解析：  

<img src="./stateMachine.jpeg" width="400"/>  

### 树构建算法
标记生成器识别标记，传递给树构造器，然后接受下一个字符以识别下一个标记；如此反复直到输入的结束。在创建解析器的同时，也会创建 Document 对象。在树构建阶段，以 Document 为根节点的 DOM 树也会不断进行修改，向其中添加各种元素。标记生成器发送的每个节点都会由树构建器进行处理。规范中定义了每个标记所对应的 DOM 元素，这些元素会在接收到相应的标记时创建。这些元素不仅会添加到 DOM 树中，还会添加到开放元素的堆栈中。此堆栈用于纠正嵌套错误和处理未关闭的标记。其算法也可以用状态机来描述。这些状态称为“插入模式”。  

看下面代码的树构建过程图解：
```html
<html>
  <body>
    Hello world
  </body>
</html>
```
<img src="./images/htmlTree.gif">

## 解析器输出

解析器的输出“解析树”是由 DOM(Document Object Model)（文档对象模型） 元素和属性节点构成的树结构。DOM 是 HTML 文档的对象表示，同时也是外部内容（例如 JavaScript）与 HTML 元素之间的接口。解析树的根节点是“Document”对象。

DOM 与标记之间几乎是一一对应的关系。比如下面这段标记：
```html
<html>
  <body>
    <p>
      Hello World
    </p>
    <div> <img src="example.png"/></div>
  </body>
</html>
```
可翻译成如下的 DOM 树：
<img src="./images/domTree.png">

## 解析后

在解析结束后，浏览器会将文档标注为交互状态，并开始解析那些处于 _deferred_ 模式的脚本，也就是那些应在文档解析完成后菜才执行的脚本。然后，文档状态将设置为“完成”，一个“加载”事件（`DOMContentLoaded`）将随之触发。

# CSS 解析
和HTML不同，CSS是上下文无关的语法，CSS的词法和语法定义在CSS规范中。
## WebKit CSS 解析器
WebKit 使用 Flex 和 Bison 解析器生成器，通过 CSS 语法文件自动创建解析器。正如我们之前在解析器简介中所说，Bison 会创建自下而上的移位归约解析器。Firefox 使用的是人工编写的自上而下的解析器。这两种解析器都会将 CSS 文件解析成 StyleSheet 对象，且每个对象都包含 CSS 规则。CSS 规则对象则包含选择器和声明对象，以及其他与 CSS 语法对应的对象。
<img src="./images/cssParse.png">



# 处理脚本和样式表的顺序
## 脚本
当解析器遇到`<script>` 标记时立即解析并执行脚本。文档解析将停止，直到脚本执行完毕（如果是外部脚本，等从网络同步抓取资源完成后再解析执行）。如果脚本标注为`defer`，则会等到文档解析结束后执行，标注为`async`（HTML5新增选项），则会由其他线程解析和执行。
## 预解析
在Webkit和Firefox中，在执行脚本时，其他线程会解析文档的其余部分，找出并加载需要通过网络加载的其他资源，通过这种方式，资源可以在并行连接上加载，从而提高总体速度。需要注意的是，预解析器不会修改DOM树，而是将这项工作交由主解析器处理；预解析器只会解析外部资源（例如外部脚本、样式表和图片）的引用。
## 样式表
另一方面，样式表有着不同的模型。理论上来说，应用样式表不会更改 DOM 树，因此似乎没有必要等待样式表并停止文档解析。但这涉及到一个问题，就是脚本在文档解析阶段会请求样式信息。如果当时还没有加载和解析样式，脚本就会获得错误的回复，这样显然会产生很多问题。这看上去是一个非典型案例，但事实上非常普遍。Firefox 在样式表加载和解析的过程中，会禁止所有脚本。而对于 WebKit 而言，仅当脚本尝试访问的样式属性可能受尚未加载的样式表影响时，它才会禁止该脚本。
# 源地址
- [浏览器的工作原理：新式网络浏览器幕后揭秘](https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#The_browsers_we_will_talk_about) 
- 极客时间的“重学前端”课程  